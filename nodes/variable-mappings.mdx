---
title: "Variable Mappings"
description: "Reference data across nodes using Jinja2 template syntax - a universal feature in Splox"
---

## Overview

Variable mappings are a fundamental feature in Splox that allow nodes to access and reference data from previous nodes in the workflow. **All node types support variable mappings.**

<div className="block dark:hidden">
  <img
    src="https://splox-app.s3.amazonaws.com/019a0b71-bc82-70e9-9edf-cec96f34e9f2_019a0b48-c2a8-70e5-843c-bd1a8ce78cb1-light.png"
    alt="Variable Mapping interface in node editor"
    style={{ maxWidth: '100%', margin: '20px auto', display: 'block', borderRadius: '8px' }}
  />
</div>

<div className="hidden dark:block">
  <img
    src="https://splox-app.s3.amazonaws.com/019a0b48-c2a8-70e5-843c-bd1a8ce78cb1.png"
    alt="Variable Mapping interface in node editor"
    style={{ maxWidth: '100%', margin: '20px auto', display: 'block', borderRadius: '8px' }}
  />
</div>

---

## How Variable Mappings Work

<Steps>
  <Step title="Select Source Node">
    Choose which previous node's output you want to access
    
    **Available nodes:** Any node that has already executed in the workflow
  </Step>
  
  <Step title="Define Mapping Name">
    Give the mapping a name to reference in templates
    
    **Example:** `user_data`, `api_response`, `search_results`
  </Step>
  
  <Step title="Use in Templates">
    Reference the mapped data using Jinja2 template syntax
    
    **Syntax:** `{{ mapping_name.field }}`
  </Step>
</Steps>

---

## Configuration Structure

Variable mappings are stored in the node configuration:

```json
{
  "variable_mappings": [
    {
      "node_json_schema_id": "abc-123-456",
      "mapping_name": "user_data"
    },
    {
      "node_json_schema_id": "def-789-012",
      "mapping_name": "api_response"
    }
  ]
}
```

---

## Template Syntax (Jinja2)

Once mapped, use Jinja2 syntax to access the data:

<Tabs>
  <Tab title="Basic Access">
    **Reference mapped variables**
    
    ```django
    {{ user_data }}                     <!-- Entire output -->
    {{ user_data.name }}                <!-- Specific field -->
    {{ user_data.profile.email }}       <!-- Nested field -->
    {{ api_response.items.0 }}          <!-- Array element -->
    ```
  </Tab>
  
  <Tab title="Filters">
    **Transform data inline**
    
    ```django
    {{ user_data.name|upper }}          <!-- Convert to uppercase -->
    {{ user_data.name|lower }}          <!-- Convert to lowercase -->
    {{ api_response.items|length }}     <!-- Get array length -->
    {{ data|json }}                     <!-- Convert to JSON string -->
    {{ number|int }}                    <!-- Convert to integer -->
    ```
  </Tab>
  
  <Tab title="Conditionals">
    **Dynamic logic**
    
    ```django
    {% if user_data.role == "admin" %}
      Admin access granted
    {% else %}
      User access only
    {% endif %}
    
    {% if api_response.items|length > 0 %}
      Found {{ api_response.items|length }} items
    {% endif %}
    ```
  </Tab>
  
  <Tab title="Loops">
    **Iterate over collections**
    
    ```django
    {% for item in api_response.items %}
      - {{ item.name }}: {{ item.value }}
    {% endfor %}
    
    {% for key, value in user_data %}
      {{ key }}: {{ value }}
    {% endfor %}
    ```
  </Tab>
</Tabs>

---

## Nodes That Support Variable Mappings

**All node types support variable mappings**, allowing you to reference data from previous nodes throughout your entire workflow.

<AccordionGroup>
  <Accordion title="Start Node" icon="play">
    - Access trigger data (`{{ start.text }}`, `{{ start.chat_id }}`, `{{ start.files }}`)
    - Reference workflow inputs and webhook payloads
  </Accordion>
  
  <Accordion title="Agent Node" icon="robot">
    - Include context in system prompts and user messages
    - Reference outputs from previous nodes for dynamic instructions
  </Accordion>
  
  <Accordion title="Tool Node" icon="wrench">
    - Pass data as tool parameters and inputs
    - Reference upstream outputs for dynamic tool arguments
  </Accordion>
  
  <Accordion title="Switch Node" icon="code-branch">
    - Use in condition evaluation and branching logic
    - Reference data to determine which branch to follow
  </Accordion>
  
  <Accordion title="Merge Node" icon="code-merge">
    - Access merged data from parallel branches
    - Reference outputs from all converging paths
  </Accordion>
</AccordionGroup>

<Info>
  Variable mappings are a universal feature in Splox. Every node can access outputs from any previously executed node in the workflow.
</Info>

---

## Common Use Cases

<CardGroup cols={2}>
  <Card title="API Response Formatting" icon="code">
    Map API node output and format for LLM consumption
    
    ```django
    {{ api_data.results|json }}
    ```
  </Card>
  
  <Card title="User Context" icon="user">
    Pass user information between nodes
    
    ```django
    User {{ user.name }} ({{ user.email }})
    ```
  </Card>
  
  <Card title="Conditional Logic" icon="code-branch">
    Make decisions based on previous outputs
    
    ```django
    {% if result.status == "success" %}
    ```
  </Card>
  
  <Card title="Data Transformation" icon="rotate">
    Transform data formats between nodes
    
    ```django
    {{ data.items|length }} items found
    ```
  </Card>
</CardGroup>

<Info>
  **Jinja2 Documentation:** Splox uses the Gonja template engine (Jinja2 for Go). Full syntax reference: [https://github.com/NikolaLohworkarinski/gonja](https://github.com/nikolalohinski/gonja)
</Info>

---

## What's Next?

<CardGroup cols={2}>
  <Card title="Agent Node" icon="robot" href="/nodes/agent-node">
    Use variable mappings in Agent system prompts
  </Card>
  
  <Card title="Tool Node" icon="wrench" href="/nodes/tool-node">
    Pass dynamic data to tool parameters
  </Card>
  
  <Card title="Switch Node" icon="code-branch" href="/nodes/switch-node">
    Reference data in Switch node conditions
  </Card>
  
  <Card title="Start Node" icon="play" href="/nodes/start-node">
    See what data the Start node provides
  </Card>
</CardGroup>
