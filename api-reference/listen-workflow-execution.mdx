---
title: 'Listen to Workflow Execution (SSE)'
openapi: 'GET /workflow-requests/{id}/listen'
---

Streams real-time execution updates via Server-Sent Events (SSE) as the workflow runs.

## Usage

<CodeGroup>

```bash cURL
curl -N -H "Authorization: Bearer YOUR_TOKEN" \
  https://app.splox.io/api/v1/workflow-requests/{workflow_request_id}/listen
```

```python Python
from splox import SploxClient

client = SploxClient(api_key="YOUR_API_KEY")

for event in client.workflows.listen("WORKFLOW_REQUEST_ID"):
    if event.is_keepalive:
        continue
    if event.node_execution:
        ne = event.node_execution
        print(f"[{ne.status}] Node {ne.node_id}")
    if event.workflow_request:
        wr = event.workflow_request
        if wr.status in ("completed", "failed", "stopped"):
            print(f"Workflow {wr.status}")
            break
```

```typescript Node.js
import Splox from "splox";

const client = new Splox("YOUR_API_KEY");

const stream = await client.workflows.listen("WORKFLOW_REQUEST_ID");
for await (const event of stream) {
  if (event.isKeepalive) continue;
  if (event.node_execution) {
    console.log(`[${event.node_execution.status}] Node ${event.node_execution.node_id}`);
  }
  if (event.workflow_request) {
    const status = event.workflow_request.status;
    if (["completed", "failed", "stopped"].includes(status)) {
      console.log(`Workflow ${status}`);
      break;
    }
  }
}
```

```go Go
client := splox.NewClient("YOUR_API_KEY")

iter, err := client.Workflows.Listen(ctx, "WORKFLOW_REQUEST_ID")
if err != nil {
    log.Fatal(err)
}
defer iter.Close()

for iter.Next() {
    ev := iter.Event()
    if ev.IsKeepalive {
        continue
    }
    if ev.NodeExecution != nil {
        fmt.Printf("[%s] Node %s\n", ev.NodeExecution.Status, ev.NodeExecution.NodeID)
    }
    if ev.WorkflowRequest != nil {
        switch ev.WorkflowRequest.Status {
        case "completed", "failed", "stopped":
            fmt.Printf("Workflow %s\n", ev.WorkflowRequest.Status)
            return
        }
    }
}
```

</CodeGroup>

## How It Works

1. On connection, all existing node executions are sent immediately
2. Then the stream subscribes to real-time updates via Redis PubSub
3. Each event contains a `workflow_request` and/or `node_execution` update
4. Keepalive messages (`data: keepalive`) are sent every 3 seconds
5. The stream closes when the workflow completes, fails, or stops

## Response Format

Standard SSE format — each event is a `data:` line followed by two newlines:

```
data: {"workflow_request":{...},"node_execution":{...}}

data: keepalive

data: {"workflow_request":{"id":"...","status":"completed",...}}
```

Each event payload contains:

```json
{
  "workflow_request": {
    "id": "0199f123-d60e-7ffd-9131-4cc5ab040ee8",
    "status": "in_progress",
    "workflow_version_id": "0199e001-a23b-7c8d-1234-567890abcdef"
  },
  "node_execution": {
    "id": "0199f124-e70f-8gge-2242-5dd6bc151ff9",
    "node_id": "0199e002-b34c-8d9e-2345-678901bcdef0",
    "status": "completed",
    "output_data": { "text": "Here is the result..." }
  }
}
```

## Status Values

**Workflow Request:**
- `pending` — Request received, waiting to start
- `in_progress` — Currently executing
- `waiting` — Paused, waiting for input (e.g., tool approval)
- `completed` — Finished successfully
- `failed` — Execution failed
- `stopped` — Manually stopped

**Node Execution:**
- `pending` — Queued
- `in_progress` — Currently executing
- `completed` — Finished successfully
- `failed` — Execution failed
- `blocked` — Waiting for dependencies
- `skipped` — Skipped (conditional branch not taken)
- `stopped` — Manually stopped
- `waiting` — Paused, waiting for input

## Notes

<Info>
**Authentication required:** Include Bearer token in Authorization header.
</Info>

<Warning>
**Connection timeout:** SSE connections timeout after 30 minutes. Reconnect if needed.
</Warning>
